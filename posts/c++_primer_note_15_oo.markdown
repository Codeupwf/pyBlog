---
layout: post
title: "C++Primer 笔记 15章 面向对象编程"
date: 2010-09-10 20:02:17
comments: true
categories: C++,面向对象,笔记
---

### C++Primer 笔记 15章 面向对象编程

##### 动态绑定

通过基类的引用或指针调用虚函数时，发声动态绑定。        
引用或指针既可以指向基类对象，也可以指向派生类对象，这一事实是动态绑定的关键。     
用引用或指针调用的虚函数在运行时所执行的函数是引用或指针所指向的对象实际类型所定义的实现。

    这里要注意的是，必须是调用虚函数时才会发生动态绑定，如果调用基类中没有指明为virtual的函数，则直接调用基类的实现，不会调用派生类的复写实现。

引用和指针的静态类型（编译时可知的类型）与动态类型（指针或引用所绑定的对象的实际类型，这是仅在运行时才可知的）可以不同，这是C++可以实现***多态性***的基石。

#####作用域限定符
使用作用域限定符可以**覆盖虚函数机制**并强制函数调用使用虚函数的特定实现版本。       
示例： 

```c++
Item_base* baseP = &child;
double d = baseP->Item_base::net_price(42);
```
这段代码将强制调用Item_base中定义的net_price()实现，不会随着baseP指针指向对象的实际类型二变化。    
派生类虚函数调用基类实现版本时，必须显式使用作用域限定符。

--more--

#####虚函数的默认实参
虚函数的默认实参的值由调用该函数的类型定义，与对象的动态类型无关。       
在同一虚函数的基类实现和派生类实现中使用不同的默认实参几乎一定会引起麻烦。       
如果通过基类的应用或指针调用虚函数，但实际执行的是派生类中定义的实现版本（应用或指针指向派生类对象），这时就可能会出现问题，因为此时基类定义的默认实参值将传递给派生类的实现，而非使用派生类自己定义的默认实参来调用。

#####is a
所有的基类与派生类的关系应该遵循派生类“**是一种（is a）**”基类的关系。    
而非派生类“**有一个（has a）**”基类。

#####继承访问级别
派生类可以恢复继承成员的访问级别。   
例如类A private实现继承类B，类B中有Public成员size，那么，在类A的public部分中增加using声明即可。    
示例： 
```c++
class A :private B{
public:
    using B::size;
}
```

+ 派生类可以恢复继承成员的访问级别，但是不能使访问级别比基类中原来指定的更严格或更宽松。

+ 使用class保留字派生时默认具有private继承，使用struct时默认具有public继承，但是使用默认继承是非常罕见的，不论何时都应显式指明继承的派生保护级别。

#####继承与静态成员
如果基类定义了static成员，则***整个继承层次中只有这一个这样的成员***。       
无论从基类派生出了多少个派生类，所有这些类在访问static成员时所访问的是同一个成员。

#####基类与派生类的转换
派生类可以转换为基类，但仅仅局限于引用与指针。     
还有用派生类对象对基类对象进行初始化，初始化时派生类的自有部分被忽略。     

从基类到派生类没有自动的转换，就算是基类的指针指向派生类对象，当用这个指针给派生类指针赋值时也会出现编译错误。因为编译器无法知道动态的绑定是否安全，只能通过静态类型来盘判断操作是否安全。       
如果此操作真的安全，那么可以使用static_cast强制编译器进行转换，或者使用dynamic_cast申请在运行时检查。 

To Be Continued 2010/9/12