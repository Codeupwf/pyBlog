---
layout: post
title: "C++Primer 笔记 14章 重载操作符与转换"
date: 2010-09-08 20:02:17
comments: true
categories: C++,重载操作符,笔记
---

### C++Primer 笔记 14章 重载操作符与转换

#### 重载操作符

#####重载的操作名：

可重载操作符：

    + - * / % ^     
    & | ~ ! , =     
    < > <= >= ++ --     
    << >> == != && ||   
    += -= /= %= ^= &=   
    |= *= <<= >>= [] ()     
    -> ->* new new [] delete delete []  

不可重载操作符：

    :: .* . ?: 

通过连接其他合法符号可以创建新的操作符。例如，定义一个 operator** 
以提供求幂运算是合法的。

    内置逻辑与（&&）和内置逻辑或（||）操作符使用短路求值，如果重新定义该操作符，丢失操作符的短路求值特征。

如果要将类用作关联容器键类型，则应定义<操作符和==操作符，因为许多算法假定这些操作符是存在的。
例如sort算法使用<操作符，而find算法使用==操作符。

如果定义了==操作符，相应的也应该定义不等操作符!=。而如果定义了<或某个关系操作符，则应将全部四个关系操作符都定义（>,>=,<,<=）

--more--

#####成员与非成员操作符重载：

+ 成员操作符重载有一个默认的参数即当前对象的this指针，这是默认的左操作数，所以赋值运算符=重载时只需要一个右操作数作为参数既可。ClassType& operator = (const ClassType&);

+ 当左操作数不是当前类的对象时，我们就必须使用非成员实现方式，例如输出操作符<<的左操作数应该是ostream对象。ostream& operator<< (ostream& out,const ClassType& s);

#####成员或非成员实现：

+ 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）等操作符必须定义为成员，将这些定义为非成员函数将在编译时出错。
+ 改变对象状态或与给定类型紧密联系的其他一些操作符，如自增、自减和解引用，通常应定义为成员函数。
+ 对称的操作符，如算术操作符、相等操作符、关系操作符和位操作符，最好定义为普通非成员函数。

#####输入输出操作符重载：

当重载输出操作符的时候所做的格式或应尽量的少尤其不要输出换行符，如果需要对输出进行格式化，我们应该让用户自己来控制输出细节。

重载**输入操作符**与重载**输出操作符**的不同点有2点：

1. 形参表第二个形参的修饰符不同，输出操作符为const而输入操作符没有const
2. 更重要的是，输入操作符必须处理错误和文件结束的可能性。

+ 使用**输入操作符**时要进行错误检查，我们无需对每次读入都进行检查，只要在使用输入数据之前检查一次就可以了。
+ 错误检查直接使用if(istream)就可以了，如果输入期间出现错误，则istream对象为为0。
+ 有时候我们还应该对流状态进行设置，但是一般只设置failbit对于badbit和eofbit最好是留给IO标准库自己来指出。iostream.setstate(failbit);//流条件状态章节 C++Primer 247页第八章标准IO库

#####算术操作符与关系操作符重载：

算术操作符与关系操作符一般都定义为非成员实现，而且如果既定义了算术操作符有定义了相关符合操作符，一般应使用复合赋值实现算术操作符。 
相等操作符==的定义中返回值为inline bool ，示例：inline bool operator == (const ClassType& lhs,const ClassType& rhs);
不等操作符!=应该调用相等操作符来完成。示例：inline bool operator != (const ClassType& lhs,const ClassType& rhs) { return  !(lhs == rhs) ; }

当类定义函数的时候，尤其是操作符重载函数的时候，要注意参数的const属性，有时要定义一个const版本还要定义一个非const版本。

返回值的const与否也要注意。这些都应根据类的具体使用情况来判断。

如果定义了下标操作符，通常情况下要定义const和非const两个版本。他们的函数体应该是一样的，只是在函数名声明定义时有关键字不同。

示例：   
```c++
const int &operator[](const size_t) const; //const版本         
int &operator[](const size_t);//非const版本
```

    const版本中第一个const为返回值的修饰，       
    第二个const为参数修饰关键字，       
    第三个const为函数修改成员权限的修饰关键字。        

#####自增自减操作符重载：

自增自减的**前缀式**与**后缀式**的区分靠的是参数表中的int参数，这个形参是无用的，它唯一的目的是使后缀函数与前缀函数区分开来。***后缀式写这个参数，前缀式没有***。

自增自减操作符的后缀式重载时，应与内置操作符一致，返回旧值（即尚未自增或自减的值），并且返回值而不是引用。

示例： 

+ 前缀式 ClassType& operator++(); 
+ 后缀式 ClassType operator++(int);//一般情况下，后缀式用前缀式实现。

#####调用操作符重载

定义了调用操作符的类，其对象常称为函数对象（Function Object），即它们是行为类似函数的对象。
```c++
struct absInt{
    int operator() (int val){
        return val < 0 ? - val : val;
        }
};

int i=42;
absInt absObj;
unsigned int ui = absObj(i);
```

标准库函数对象使用时要包含functional头文件，有算术函数对象类型、关系函数对象类型、逻辑函数对象类象，就是各种操作符的函数对象，例如plus<Type> 对应+。
用法：函数对象通常用于覆盖算法使用的默认操作符。如sort默认使用operator<按升序对容器进行排序。
如果要降序排列则可以传递函数对象greater。 示例：sort(svec.begin(),svec.end(),greater<string>());

#### 转换

#####标准库函数对象

**标准库函数对象**使用时要包含functional.h头文件，有算术函数对象类型、关系函数对象类型、逻辑函数对象类象，就是各种操作符的函数对象。
例如plus<Type> 对应+。

用法：

+ 函数对象通常用于覆盖算法使用的默认操作符。如sort默认使用operator<按升序对容器进行排序。
+ 如果要降序排列则可以传递函数对象greater。 
示例：sort(svec.begin(),svec.end(),greater<string>());
 
#####函数对象的函数适配器

**函数对象的函数适配器**有两类

+ 绑定器（binder），它通过将一个操作数绑定到给定值而将二元函数对象转换为一元函数对象。     
有bind1st和bind2nd两个，bind1st将给定值绑定到二元函数对象的第一个实参，bind2nd绑定到第二个实参。

+ 求反器（negator），它将谓词函数对象的真值求反。
有not1和not2两个，not1将一元函数对象的真值求反，not2将二元函数对象的真值求反。

示例：    

+ count_if(vec.begin(), vec.end(), bind2nd(less_equal<int>(), 10) );//计算容器vec中所有小于或等于10的元素的个数。bind2nd后面等于 <=10，将二元函数对象变为一元。       

+ count_if(vec.begin(), vec.end(), not1(bind2nd(less_equal<int>(), 10) );//计算容器vec中所有不是小于等于10的元素，即大于10的元素，not1将bind2nd(less_equal<int>(), 10)的返回值求反。      

#####转换操作符

**转换操作符(conversion operator)**是一种特殊的类成员函数。它定义将类类型值转变为其他类型值的转换。转换操作符在类定义体内声明，在保留字operator之后跟着转换的目标类型。

```c++
class SmallInt { 
public: 
    SmallInt(int i = 0): val(i) 
    { 
        if (i < 0 || i > 255) 
        throw std::out_of_range("Bad SmallInt initializer"); 
    } 
    operator int() const { return val; } 
private: 
    std::size_t val;
}
```

通用形式：operator type();//没有返回值类型但是有返回值

+ 这里，type表示内置类型名、类类型名或有类型别名所定义的名字。对任何可作为函数返回类型的类型除void外都可以定义转换函数。
+ 转换函数必须是成员函数，不能指定返回值类型，并且形参表必须为空。
+ 类类型转换调用之后不能再跟另一个类类型转换。如果需要多个类类型转换，则代码将出错。

如果两个转换操作符都可用在一个调用中，而且在转换函数之后还存在标准转换，则存在一个编译错误，因为编译器无法选择转换函数。 

    一般而言，给出一个类与两个内置类型之间的转换是不好的做法。
    实际上转换操作符就是为了让类类型能够想内置类型一样能够进行隐式转换，但是只能转换一次。

#####实参匹配与转换

实参匹配与转换有时会出现二义性，情况如下：

+ 一个类含有两个以上的与内置类型之间的转换。
+ 一个类有多种单参数构造函数，同时构造函数的形参类型是可以相互转换的。当给出的实参类型可以通过内置类型转换转换为两种构造函数的形参类型时出现二义性。
+ 当两个类定义类转换时。类A可以通过成员函数转换操作符转换为类B，同时类B拥有一个接受类A形参的构造函数。这样类A有两种方式转换为类B存在二义性。


#####重载操作符与转换的冲突

要注意重载操作符与转换的冲突。     

+ 比如一个类重载了+操作符，同时又有转为int的转换，那么 obj+3 这句就存在二义性，到底是调用加号操作符重载函数呢？还是调用把obj转换为int行变量的转换呢？
+ 既为算术型提供转换函数，又为同一类类型提供重载操作符，可能会导致重载操作符与内置操作符之间的冲突。
